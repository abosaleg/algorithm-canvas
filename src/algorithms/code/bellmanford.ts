import { AlgorithmCode } from '@/types/algorithm';

export const bellmanFordCode: Record<string, AlgorithmCode> = {
  javascript: {
    language: 'javascript',
    lines: [
      'function bellmanFord(graph, V, E, src) {',
      '  const dist = Array(V).fill(Infinity);',
      '  dist[src] = 0;',
      '  ',
      '  // Relax all edges V-1 times',
      '  for (let i = 0; i < V - 1; i++) {',
      '    for (const { u, v, weight } of graph) {',
      '      if (dist[u] !== Infinity &&',
      '          dist[u] + weight < dist[v]) {',
      '        dist[v] = dist[u] + weight;',
      '      }',
      '    }',
      '  }',
      '  ',
      '  // Check for negative cycles',
      '  for (const { u, v, weight } of graph) {',
      '    if (dist[u] !== Infinity &&',
      '        dist[u] + weight < dist[v]) {',
      '      return { dist: null, hasNegativeCycle: true };',
      '    }',
      '  }',
      '  ',
      '  return { dist, hasNegativeCycle: false };',
      '}',
    ],
  },
  python: {
    language: 'python',
    lines: [
      'def bellman_ford(graph, V, src):',
      '    dist = [float("inf")] * V',
      '    dist[src] = 0',
      '    ',
      '    # Relax all edges V-1 times',
      '    for _ in range(V - 1):',
      '        for u, v, weight in graph:',
      '            if dist[u] != float("inf") and \\',
      '               dist[u] + weight < dist[v]:',
      '                dist[v] = dist[u] + weight',
      '    ',
      '    # Check for negative cycles',
      '    for u, v, weight in graph:',
      '        if dist[u] != float("inf") and \\',
      '           dist[u] + weight < dist[v]:',
      '            return None, True',
      '    ',
      '    return dist, False',
    ],
  },
  pseudocode: {
    language: 'pseudocode',
    lines: [
      'BELLMAN-FORD(graph, V, src)',
      '  dist = array of size V, all set to ∞',
      '  dist[src] = 0',
      '  ',
      '  // Relax all edges V-1 times',
      '  for i = 0 to V - 2',
      '    for each edge (u, v, weight) in graph',
      '      if dist[u] ≠ ∞ and dist[u] + weight < dist[v]',
      '        dist[v] = dist[u] + weight',
      '  ',
      '  // Check for negative cycles',
      '  for each edge (u, v, weight) in graph',
      '    if dist[u] ≠ ∞ and dist[u] + weight < dist[v]',
      '      return NULL, true  // Negative cycle found',
      '  ',
      '  return dist, false',
    ],
  },
};
